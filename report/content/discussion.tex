\section{Verified Example}

Following the definition of all Hoare rules, we will now prove the statement given in proposition \ref{prop:program-correct} correct, by decorating the program we saw in listing \ref{lst:imp-plus-ex} with formal assertions. The proof is also given in Coq code in ./src/examples.v (the theorem named $cx\_prog\_correct$).

This way, any command that can be put in a sequence will implicitly be skipped if the post-state of the first command is exceptional.

\subsection{Function calls}
The operational semantic and rule for a call introduced in this report provide the tools to verify a program, containing functions and calls, written in IMP+. An example of such a program is the one shown in listing \ref{lst:imp-plus-ex}.

However, the semantics and rules are not enough to make it practical to verify a program. The program, in listing \ref{lst:sum-recursive}, can be verified using our logic, but to do so every one of the 20 recursive calls need to be proven separately.

\begin{lstlisting}[mathescape=true,keepspaces=true,label=lst:sum-recursive,caption={A program calculating the sum of 10 and 20, using recursion}.]
(* Body of the function F *)
CALL F X [X + 1; Y - 1]

(* The environment, containing a single function F witch
   takes a parameter and has the body defined above.
   The return value is the value of X, in the scope of the 
   body after its execution *)
$\rho$ = {F $\mapsto$ (body, [X, Y], X)}

(* The program entry point *)
CALL F X [10;20]
\end{lstlisting}

\subsection{Verified Examples}

\subsubsection{Caught and Propagated Exception}

\begin{lstlisting}[mathescape=true,keepspaces=true,label=lst:hoare_ex_asgn,caption=Decorated variant of the program from listing \ref{lst:imp-plus-ex}.]
$\textbf{Body of F}$
{ X = X                         }      $\text{This is trivially true, but necessary due to}$
                                       $\text{how the assignment Hoare rule (\ref{eqn:hoare-assign}) works.}$
Y ::= X;;                              $\text{Updates the state with Y = X per the}$
                                       $\text{operational semantics for assignment (\ref{eqn:op-assign}).}$
{ Y = X $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$            }      $\text{This is now our precondition for the try-catch.}$
TRY
  { Y = X $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$          } $\Rightarrow$   $\text{Precondition as per the catch Hoare rule (\ref{eqn:hoare-catch}).}$
  { 4 = 4 $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$          }      $\text{Implies this by rule of consequence, which is}$
                                       $\text{trivially true.}$
  Y ::= 4;;                            $\text{Updates the state with X = 4 per the}$
                                       $\text{operational semantics for assignment (\ref{eqn:op-assign}).}$
  { Y = 4 $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$          }      $\text{Per the assignment Hoare rule (\ref{eqn:hoare-assign}).}$
  THROW T, [21 - Y];;                  $\text{Puts the program in an exceptional state as}$
                                       $\text{per the operational semantics for throw (\ref{eqn:op-throw}).}$
  { $\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon$ = (T, [17])          }      $\text{Follows from the Hoare rule for throw (\ref{eqn:hoare-throw}).}$
  THROW U, []                          $\text{This statement is skipped by way of the}$
                                       $\text{exception sequence Hoare rule (\ref{eqn:hoare-seq-exn}).}$
  { $\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon$ = (T, [17])          }      $\text{I.e. the exception from before is propagated.}$
CATCH T, [Z] DO
  { $\lambda \varepsilon\:\sigma\:\omega.\:\exists \sigma'.(\sigma(Y)=\sigma(X)\wedge\sigma=\sigma'[\sfrac{Z}{17}])$ } $\Rightarrow$ $\text{Follows from the catch Hoare rule (\ref{eqn:hoare-catch}).}$
                                        $\text{The state in which it holds that}$
                                        $X=5\wedge Y=5\text{ will do as a witness}$
                                        $\text{for the existential quantifier.}$
  { X = 5 $\wedge$ Y = 5 $\wedge$ Z = 17      } $\Rightarrow$    $\text{The rule of consequence leads us to this.}$
  { Y + Z = 22 $\wedge$ Y = 5 $\wedge$ Z = 17 }       $\text{Rule of consequence again.}$
  X ::= Y + Z                           $\text{Updates the state with X = 22}$
  { X = 22 $\wedge$ Y = 5 $\wedge$ Z = 17 $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$} $\text{Per the assignment Hoare rule (\ref{eqn:hoare-assign}).}$
END
{ X = 22 $\wedge$ Y = 5 $\wedge$ Z = 17 $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$} $\Rightarrow$ $\text{Follows from the catch Hoare rule (\ref{eqn:hoare-catch}).}$
{(X = 22 $\wedge$ Y = 5 $\wedge$ Z = 17 $\wedge\quad\lambda \varepsilon\:\sigma\:\omega.\:\varepsilon=\bot$)$\wedge$ 22 = X}
                                         $\text{The above follows from the rule of consequence,}$
                                         $\text{and is required as post-condition of the function}$
                                         $\text{body for the call Hoare rule (\ref{eqn:hoare-call}).}$

$\textbf{Program entry point}$

{ 5 = 5      } $\text{Precondition for assignment Hoare rule (\ref{eqn:hoare-assign}).}$
X ::= 5;;      $\text{The state is updated with X = 5.}$
{ X = 5      } $\text{Precondition for the call Hoare rule (\ref{eqn:hoare-call}).}$
CALL F X [X]   $\text{The value of X is passed as a parameter, and the return expression}$
               $\text{of the function body is bound to X, as by semantics for call (\ref{eqn:op-call}).}$
{ X = 22    }  $\text{Postcondition as per the call Hoare rule (\ref{eqn:hoare-call}).}$
               $\text{Our desired end-state as by proposition \ref{prop:program-correct}.}$
\end{lstlisting}

\section{Discussion}

\subsection{Design Choices}
The operational semantics for SEQUENCE carries the entire burden of propagating exceptions from one command to the next, in case the post-state of one, and thus the implicit pre-state of the next is exceptional. There are a few reasons for doing it this way:

\begin{itemize}
\item It simplifies the evaluation relation, since there is no need to explicitly model the concept of an exceptional pre-state
\item We avoid having to add an additional rule for every command that makes it explicitly behave as SKIP in the presence of an exception
\end{itemize}

This way, any command that can be put in a sequence will implicitly be skipped if the post-state of the first command is exceptional.
